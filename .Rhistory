gold_pr <- read.csv("gold-2004.csv")
dualplot <- function(x1, y1, y2, x2 = x1,
col = c("#C54E6D", "#009380"),
lwd = c(1, 1), colgrid = NULL,
mar = c(3, 6, 3, 6) + 0.1,
ylab1 = paste(substitute(y1), collapse = ""),
ylab2 = paste(substitute(y2), collapse = ""),
nxbreaks = 5,
yleg1 = paste(gsub("\n$", "", ylab1), "(left axis)"),
yleg2 = paste(ylab2, "(right axis)"),
ylim1 = NULL, ylim2 = NULL, ylim.ref = NULL,
xlab = "", main = NULL, legx = "topleft", legy = NULL,
silent = FALSE, bty = "n", ...){
# Base graphics function for drawing dual axis line plot.
# Assumed to be two time series on a conceptually similar, non-identical scale
#
# Assumes data is in sequence of x1 and of x2 ie ordered by time
#
# Use with caution!
# Please don't use to show growth rates and the original
# series at the same time!
#
# Peter Ellis, 16-27 August 2016, GNU GPL-3
# most parameters should be obvious:
# x1 and y1 are the x and y coordinates for first line
# x2 and y2 are the x and y coordinates for second line.  Often x2 will == x1, but can be overridden
# ylim1 and ylim2 are the vertical limits of the 2 axes.  Recommended NOT to use these, as
#    the default algorithm will set them in a way that makes the axes equivalent to using an index (for
#    positive data) or mean of each series +/- 3 standard deviations (if data include negatives)
# ylim.ref the two numbers in the two series to use as the reference point for converting them to indices
#    when drawing on the page.  If both elements are 1, both series will start together at the left of the plot.
# nbreaks is number of breaks in horizontal axis
# lwd and mar are graphics parameters (see ?par)
# colgrid is colour of gridlines; if NULL there are no gridlines
# ylab1 and ylab2 are the labels for the two y axes
# yleg1 and yleg2 are the labels for the two series in the legend
# xlab and main are for x label and main title as in plot()
# legx and legy are x and y position fed through to legend()
# ... is parameters to pass to legend()
# Note that default colours were chosen by colorspace::rainbow_hcl(2, c = 80, l = 50)
# strip excess attributes (eg xts etc) from the two vertical axis variables
ylab1 <- as.character(ylab1)
ylab2 <- as.character(ylab2)
y1 <- as.numeric(y1)
y2 <- as.numeric(y2)
# is ylim.ref is NULL, calculate a good default
if(is.null(ylim.ref)){
if (length(y1) == length(y2)){
ylim.ref <- c(1, 1)
} else {
if (min(x1) >  min(x2)){
ylim.ref <- c(1, which(abs(x2 - min(x1)) == min(abs(x2 - min(x1)))))
} else {
ylim.ref <- c(which(abs(x1 - min(x2)) == min(abs(x1 - min(x2)))), 1)
}
}
}
oldpar <- par(mar = mar)
xbreaks <- round(seq(from = min(c(x1, x2)), to = max(c(x1, x2)), length.out = nxbreaks))
# unless ylim1 or ylim2 were set, we set them to levels that make it equivalent
# to a graphic drawn of indexed series (if all data positive), or to the mean
# of each series +/- three standard deviations if some data are negative
if(is.null(ylim1) & is.null(ylim2)){
if(min(c(y1, y2), na.rm = TRUE) < 0){
message("With negative values ylim1 or ylim2 need to be chosen by a method other than treating both series visually as though they are indexed. Defaulting to mean value +/- 3 times the standard deviations.")
ylim1 <- c(-3, 3) * sd(y1, na.rm = TRUE) + mean(y1, na.rm = TRUE)
ylim2 <- c(-3, 3) * sd(y2, na.rm = TRUE) + mean(y2, na.rm = TRUE)
}
if(ylim.ref[1] > length(y1)){
stop("ylim.ref[1] must be a number shorter than the length of the first series.")
}
if(ylim.ref[2] > length(y2)){
stop("ylim.ref[2] must be a number shorter than the length of the second series.")
}
if(!silent) message("The two series will be presented visually as though they had been converted to indexes.")
# convert the variables to indexes (base value of 1 at the time specified by ylim.ref)
ind1 <- as.numeric(y1) / y1[ylim.ref[1]]
ind2 <- as.numeric(y2) / y2[ylim.ref[2]]
# calculate y axis limits on the "index to 1" scale
indlimits <- range(c(ind1, ind2), na.rm = TRUE)
# convert that back to the original y axis scales
ylim1 = indlimits * y1[ylim.ref[1]]
ylim2 = indlimits * y2[ylim.ref[2]]
} else {
if(!silent) warning("You've chosen to set at least one of the vertical axes limits manually.  Up to you, but it is often better to leave it to the defaults.")
}
# draw first series - with no axes.
plot(x1, y1, type = "l", axes = FALSE, lwd = lwd[1],
xlab = xlab, ylab = "", col = col[1], main = main,
xlim = range(xbreaks), ylim = ylim1)
# add in the gridlines if wanted:
if(!is.null(colgrid)){
grid(lty = 1, nx = NA, ny = NULL, col = colgrid)
abline(v = xbreaks, col = colgrid)
}
# add in the left hand vertical axis and its label
axis(2, col = col[1], col.axis= col[1], las=1 )  ## las=1 makes horizontal labels
mtext(paste0("\n", ylab1, "\n"), side = 2, col = col[1], line = 1.5)
# Allow a second plot on the same graph
par(new=TRUE)
# Plot the second series:
plot(x2, y2,   xlab="", ylab="", axes = FALSE, type = "l", lwd = lwd[2],
col = col[2], xlim = range(xbreaks), ylim = ylim2)
## add second vertical axis (on right) and its label
mtext(paste0("\n", ylab2, "\n"), side = 4, col = col[2], line = 4.5)
axis(4,  col = col[2], col.axis = col[2], las=1)
# Draw the horizontal time axis
axis(1, at = xbreaks, labels = xbreaks)
# Add Legend
legend(x = legx, y = legy, legend=c(yleg1, yleg2),
text.col = col, lty = c(1, 1), lwd = lwd, col = col,
bty = bty, ...)
par(oldpar)
}
setwd("C:\Users\samue\Downloads\Studium\Economics (Master - Vienna)\2. Semester\Macroeconometrics\Project")
setwd("\Users\samue\Downloads\Studium\Economics (Master - Vienna)\2. Semester\Macroeconometrics\Project")
setwd("/Users/samue/Downloads/Studium/Economics (Master - Vienna)/2. Semester/Macroeconometrics/Project")
# import search trends
data <- read.csv("btc-vs-gold-2004.csv")
# import prices data:
gold_pr <- read.csv("gold-2004.csv")
dualplot <- function(x1, y1, y2, x2 = x1,
col = c("#C54E6D", "#009380"),
lwd = c(1, 1), colgrid = NULL,
mar = c(3, 6, 3, 6) + 0.1,
ylab1 = paste(substitute(y1), collapse = ""),
ylab2 = paste(substitute(y2), collapse = ""),
nxbreaks = 5,
yleg1 = paste(gsub("\n$", "", ylab1), "(left axis)"),
yleg2 = paste(ylab2, "(right axis)"),
ylim1 = NULL, ylim2 = NULL, ylim.ref = NULL,
xlab = "", main = NULL, legx = "topleft", legy = NULL,
silent = FALSE, bty = "n", ...){
# Base graphics function for drawing dual axis line plot.
# Assumed to be two time series on a conceptually similar, non-identical scale
#
# Assumes data is in sequence of x1 and of x2 ie ordered by time
#
# Use with caution!
# Please don't use to show growth rates and the original
# series at the same time!
#
# Peter Ellis, 16-27 August 2016, GNU GPL-3
# most parameters should be obvious:
# x1 and y1 are the x and y coordinates for first line
# x2 and y2 are the x and y coordinates for second line.  Often x2 will == x1, but can be overridden
# ylim1 and ylim2 are the vertical limits of the 2 axes.  Recommended NOT to use these, as
#    the default algorithm will set them in a way that makes the axes equivalent to using an index (for
#    positive data) or mean of each series +/- 3 standard deviations (if data include negatives)
# ylim.ref the two numbers in the two series to use as the reference point for converting them to indices
#    when drawing on the page.  If both elements are 1, both series will start together at the left of the plot.
# nbreaks is number of breaks in horizontal axis
# lwd and mar are graphics parameters (see ?par)
# colgrid is colour of gridlines; if NULL there are no gridlines
# ylab1 and ylab2 are the labels for the two y axes
# yleg1 and yleg2 are the labels for the two series in the legend
# xlab and main are for x label and main title as in plot()
# legx and legy are x and y position fed through to legend()
# ... is parameters to pass to legend()
# Note that default colours were chosen by colorspace::rainbow_hcl(2, c = 80, l = 50)
# strip excess attributes (eg xts etc) from the two vertical axis variables
ylab1 <- as.character(ylab1)
ylab2 <- as.character(ylab2)
y1 <- as.numeric(y1)
y2 <- as.numeric(y2)
# is ylim.ref is NULL, calculate a good default
if(is.null(ylim.ref)){
if (length(y1) == length(y2)){
ylim.ref <- c(1, 1)
} else {
if (min(x1) >  min(x2)){
ylim.ref <- c(1, which(abs(x2 - min(x1)) == min(abs(x2 - min(x1)))))
} else {
ylim.ref <- c(which(abs(x1 - min(x2)) == min(abs(x1 - min(x2)))), 1)
}
}
}
oldpar <- par(mar = mar)
xbreaks <- round(seq(from = min(c(x1, x2)), to = max(c(x1, x2)), length.out = nxbreaks))
# unless ylim1 or ylim2 were set, we set them to levels that make it equivalent
# to a graphic drawn of indexed series (if all data positive), or to the mean
# of each series +/- three standard deviations if some data are negative
if(is.null(ylim1) & is.null(ylim2)){
if(min(c(y1, y2), na.rm = TRUE) < 0){
message("With negative values ylim1 or ylim2 need to be chosen by a method other than treating both series visually as though they are indexed. Defaulting to mean value +/- 3 times the standard deviations.")
ylim1 <- c(-3, 3) * sd(y1, na.rm = TRUE) + mean(y1, na.rm = TRUE)
ylim2 <- c(-3, 3) * sd(y2, na.rm = TRUE) + mean(y2, na.rm = TRUE)
}
if(ylim.ref[1] > length(y1)){
stop("ylim.ref[1] must be a number shorter than the length of the first series.")
}
if(ylim.ref[2] > length(y2)){
stop("ylim.ref[2] must be a number shorter than the length of the second series.")
}
if(!silent) message("The two series will be presented visually as though they had been converted to indexes.")
# convert the variables to indexes (base value of 1 at the time specified by ylim.ref)
ind1 <- as.numeric(y1) / y1[ylim.ref[1]]
ind2 <- as.numeric(y2) / y2[ylim.ref[2]]
# calculate y axis limits on the "index to 1" scale
indlimits <- range(c(ind1, ind2), na.rm = TRUE)
# convert that back to the original y axis scales
ylim1 = indlimits * y1[ylim.ref[1]]
ylim2 = indlimits * y2[ylim.ref[2]]
} else {
if(!silent) warning("You've chosen to set at least one of the vertical axes limits manually.  Up to you, but it is often better to leave it to the defaults.")
}
# draw first series - with no axes.
plot(x1, y1, type = "l", axes = FALSE, lwd = lwd[1],
xlab = xlab, ylab = "", col = col[1], main = main,
xlim = range(xbreaks), ylim = ylim1)
# add in the gridlines if wanted:
if(!is.null(colgrid)){
grid(lty = 1, nx = NA, ny = NULL, col = colgrid)
abline(v = xbreaks, col = colgrid)
}
# add in the left hand vertical axis and its label
axis(2, col = col[1], col.axis= col[1], las=1 )  ## las=1 makes horizontal labels
mtext(paste0("\n", ylab1, "\n"), side = 2, col = col[1], line = 1.5)
# Allow a second plot on the same graph
par(new=TRUE)
# Plot the second series:
plot(x2, y2,   xlab="", ylab="", axes = FALSE, type = "l", lwd = lwd[2],
col = col[2], xlim = range(xbreaks), ylim = ylim2)
## add second vertical axis (on right) and its label
mtext(paste0("\n", ylab2, "\n"), side = 4, col = col[2], line = 4.5)
axis(4,  col = col[2], col.axis = col[2], las=1)
# Draw the horizontal time axis
axis(1, at = xbreaks, labels = xbreaks)
# Add Legend
legend(x = legx, y = legy, legend=c(yleg1, yleg2),
text.col = col, lty = c(1, 1), lwd = lwd, col = col,
bty = bty, ...)
par(oldpar)
}
plot(gold_pr$GOLDPMGBD228NLBM,type = 'l', lwd = 2, col = 'red',
ylim = c(0,2000))
lines(25*data$GOLD, lwd = 2, col = 'blue')
plot(data$GOLD)
length(gold_pr$DATE)
length(gold_pr$GOLDPMGBD228NLBM)
length(gold)
dualplot(x1 = gold_pr$DATE, y1 = gold_pr$GOLDPMGBD228NLB,
x2 = gold_pr$DATE, y2 = data$GOLD,
ylab1 = "Gold Price", ylab2 = "Gold Search Interest",
ylim1 = c(200,2000), ylim2 = c(0,100),
legx = "topright",
main = "Price and Search Interest for Gold\n(starting at same vertical position)",
ylim.ref = c(1, 1), silent = TRUE)
install.packages("vars")
install.packages("tseries")
knitr::opts_chunk$set(echo = TRUE)
gold_price_lagged <- lag(gold_price, k = 1)
install.packages("forecast")
# clear workspace
rm(list=ls())
# load needed libraries
library(readr)
library(vars)
# set working directory
setwd("/Users/samue/Downloads/Studium/Economics (Master - Vienna)/2. Semester/Macroeconometrics/Project/macroeconometrics_prices")
# import search trends
data <- read.csv("btc-vs-gold-2004.csv")
# import prices data:
gold_pr <- read.csv("gold-2004.csv")
# plot gold price
plot(gold_pr$GOLDPMGBD228NLBM,type = 'l', lwd = 2, col = 'red',
ylim = c(0,2000), main = 'Gold Price and Search Interest',
xlab = 'Time', ylab = 'Search Interest (scaled )and Price (unscaled)')
# add gold search interest scaled up
lines(25*data$GOLD, lwd = 2, col = 'blue')
legend('topleft', legend = c('search','price'),
col = c('blue','red'), bty = "n", pch = c(19,19))
# create first differenced prices and search interest
t <- length(gold_pr$DATE)
gold_price_FD <- rep(0,t-1)
for(i in 2:209){gold_price_FD[i-1] <- gold_pr$GOLDPMGBD228NLBM[i]-gold_pr$GOLDPMGBD228NLBM[i-1]}
gold_search_FD <- rep(0,t-1)
for(i in 2:209){gold_search_FD[i-1] <- data$GOLD[i]-data$GOLD[i-1]}
# plot first differenced variables
plot(gold_price_FD, type = 'l', lwd = 1, col = 'red',
xlab = 'Time', ylab = '1-Period Differences',
main = 'First Differences: Gold Price and Search Interest')
lines(gold_search_FD*8, lwd = 1, col = 'blue')
legend('topleft', legend = c('search','price'),
col = c('blue','red'), bty = "n", pch = c(19,19))
# plot ACF for unmodified variables:
par(mfrow=c(2,2))     # changes the plot layout to more easily compare them
acf(gold_pr$GOLDPMGBD228NLBM, main = 'ACF Gold Price')
acf(data$GOLD, main = 'ACF Gold Search Interest')
# plot ACF for differenced variables
acf(gold_price_FD,main = 'ACF Gold Price FD')
acf(gold_search_FD, main = 'ACF Gold Search Interest FD')
par(mfrow = c(1,1))   # revert layout changes
range01 <- function(x){(x-min(x))/(max(x)-min(x))}
plot(range01(gold_pr$GOLDPMGBD228NLBM), lwd = 2, type = 'l',
ylab = 'Scaled Price and Search Interest',
xlab = 'Time', col = 'red')
lines(range01(data$GOLD), lwd = 2, col = 'blue')
legend('topleft', legend = c('search','price'),
col = c('blue','red'), bty = "n", pch = c(19,19))
# save scaled variables
gold_price_scaled <- range01(gold_pr$GOLDPMGBD228NLBM)
gold_search_scaled <- range01(data$GOLD)
# create first difference on scaled variables:
gold_search_scaled_FD <- rep(0,t-1)
gold_price_scaled_FD <- rep(0,t-1)
for(i in 2:t-1){
gold_price_scaled_FD[i-1] <- gold_price_scaled[i]-gold_price_scaled[i-1]
}
for(i in 2:t-1){
gold_search_scaled_FD[i-1] <- gold_search_scaled[i]-gold_search_scaled[i-1]
}
# plot first differenced:
plot(gold_price_scaled_FD, lwd = 1, type = 'l',
ylab = 'FD Scaled Price and Search Interest',
xlab = 'Time', col = 'red')
lines(gold_search_scaled_FD, lwd = 1, col = 'blue')
legend('topleft', legend = c('search','price'),
col = c('blue','red'), bty = "n", pch = c(19,19))
# plot ACFs
par(mfrow=c(2,2))     # changes the plot layout to more easily compare them
acf(gold_price_scaled, main = 'ACF Scaled Gold Price')
acf(gold_search_scaled, main = 'ACF Scaled Gold Search Interest')
acf(gold_price_scaled_FD,main = 'ACF Scaled Gold Price FD')
acf(gold_search_scaled_FD, main = 'ACF Scaled Gold Search Interest FD')
par(mfrow = c(1,1))   # revert layout changes
# save variable vectors as time series format:
gold_price_scaled <- ts(gold_price_scaled, frequency = 12,
start = c(2004, 1), end = c(2021, 5))
gold_search_scaled <- ts(gold_search_scaled, frequency = 12,
start = c(2004,1), end = c(2021,5))
# set up data for estimation using `VAR()`
VAR_data <- window(ts.union(gold_price_scaled, gold_search_scaled),
start = c(2004, 1), end = c(2021, 5))
# estimate model coefficients using `VAR()`
VAR_est <- VAR(y = VAR_data, p = 2)
summary(VAR_est)
# augmented df test on only the gold price
df_test_gold <- urca::ur.df(gold_price_scaled, type = c('drift'),
selectlags = 'BIC')
summary(df_test_gold)
# augmented df test on only the differenced gold price
df_test_gold_FD <- urca::ur.df(gold_price_scaled_FD, type = 'none',
selectlags = 'BIC')
summary(df_test_gold_FD)
# VAR model with unscaled prices
# save variable vectors as time series format:
gold_price <- ts(gold_pr$GOLDPMGBD228NLBM, frequency = 12,
start = c(2004, 1), end = c(2021, 5))
gold_search <- ts(data$GOLD, frequency = 12,
start = c(2004,1), end = c(2021,5))
# set up data for estimation using `VAR()`
VAR_data <- window(ts.union(gold_price, gold_search),
start = c(2004, 1), end = c(2021, 5))
# estimate model coefficients using `VAR()`
VAR_est <- VAR(y = VAR_data, p = 1, type = 'both')
summary(VAR_est)
# compare the VAR to the AR(1) model for the prices
T <-length(gold_price)
gold_price_2 <- as.numeric(gold_price[-1])
gold_price_lagged <- as.numeric(gold_price[-T])
plot(gold_price_2, type = 'l', lwd = 1, col = 'red',
main = 'Gold Price and Lagged Gold Price',
ylab = 'Gold Price', xlab = 'Months from 01.2004')
lines(gold_price_lagged, lwd = 1, col = 'blue')
legend('topleft', legend = c('Lagged Price','Price'),
col = c('blue','red'), bty = "n", pch = c(19,19))
# estimate model
gold_price_AR1 <- lm(gold_price_2 ~ gold_price_lagged)
# estimate robust standard errors
coeftest(gold_price_AR1, vcov. = vcovHC, type = "HC1")
# verify the 'by-hand' results with built-in function
ar.ols(gold_price, order.max = 1, intercept = T)
forecast::auto.arima(gold_price, ic = 'aic')
# Differenced AR(1) and ARCH Model for Gold Prices
gold_price_FD <- ts(gold_price_FD, frequency = 12,
start = c(2004, 2), end = c(2021, 5))
plot(gold_price_FD, ylab = 'FD Gold Prices', col = 'red', lwd = 1.5)
ar1mod_FD <- arima(gold_price_FD, order = c(1,0,0))
ar1mod_FD
plot(summary(ar1mod_FD)$residuals, type = 'l', lwd = 1.5, col = 'blue)
plot(summary(ar1mod_FD)$residuals, type = 'l', lwd = 1.5, col = 'blue')
plot(ar1mod_FD$residuals, type = 'l', lwd = 1.5, col = 'blue')
plot(gold_price_FD, ylab = 'FD Gold Prices', col = 'red', lwd = 1.5)
plot(ar1mod_FD$residuals, type = 'l', lwd = 1.5, col = 'blue')
plot((ar1mod_FD$residuals)^2, type = 'l', lwd = 1.5, col = 'blue')
plot(sqrt((ar1mod_FD$residuals)^2), type = 'l', lwd = 1.5, col = 'blue')
forecast::arima.errors(gold_price_FD, order = c(1,0,0))
forecast::arima.errors(ar1mod_FD)
plot(forecast::arima.errors(ar1mod_FD),type = 'l', lwd = 1.5, col = 'blue)
plot(forecast::arima.errors(ar1mod_FD),type = 'l', lwd = 1.5, col = 'blue')
plot(forecast::arima.errors(ar1mod_FD),type = 'l', lwd = 1.5, col = 'blue')
plot(forecast::arima.errors(ar1mod_FD),type = 'l', lwd = 1.5, col = 'blue')
plot(forecast::arima.errors(ar1mod_FD),type = 'l', lwd = 1.5, col = 'blue',
ylab = 'ARIMA residuals')
forecast::arima.errors(ar1mod_FD)
mean(forecast::arima.errors(ar1mod_FD))
mean((forecast::arima.errors(ar1mod_FD))^2)
mean(forecast::arima.errors(ar1mod_FD))
install.packages("autovarCore")
install.packages("autovarCore")
install.packages("fGarch")
install.packages("aTSA")
knitr::opts_chunk$set(echo = TRUE)
# clear workspace
rm(list=ls())
# load needed libraries
library(readr)
library(vars)
library(tseries)
# set working directory
#setwd("/Users/samue/Downloads/Studium/Economics (Master - Vienna)/2. Semester/Macroeconometrics/Project/macroeconometrics_prices")
# import search trends
data <-  read_csv("btc-vs-gold-2004.csv", col_types = cols(Month = col_date(format = "%Y-%m")))
# import prices data:
gold_pr <- read_csv("gold-2004.csv", col_types = cols(DATE = col_date(format = "%Y-%m-%d")))
# import high-frequency prices for gold:
gold_HF <- read_csv('gold-2001-HF.csv', col_types = cols(DATE = col_date(format = '%Y-%m-%d')))
# Differenced MA(1) and ARCH Model for Gold Prices
gold_daily <- gold_HF$GOLDPMGBD228NLBM
t <- length(gold_daily)
gold_daily_FD <- rep(0,t-1)
for(i in 2:209){gold_daily_FD[i-1] <- gold_dauly$GOLDPMGBD228NLBM[i]-gold_daily$GOLDPMGBD228NLBM[i-1]}
for(i in 2:209){gold_daily_FD[i-1] <- gold_daily$GOLDPMGBD228NLBM[i]-gold_daily$GOLDPMGBD228NLBM[i-1]}
for(i in 2:209){gold_daily_FD[i-1] <- gold_daily[i]-gold_daily[i-1]}
# Differenced MA(1) and ARCH Model for Gold Prices
t <- length(gold_daily)
gold_daily_FD <- rep(0,t-1)
for(i in 2:209){gold_daily_FD[i-1] <- gold_HF$GOLDPMGBD228NLBM[i]-gold_HF$GOLDPMGBD228NLBM[i-1]}
for(i in 2:t){gold_daily_FD[i-1] <- gold_HF$GOLDPMGBD228NLBM[i]-gold_HF$GOLDPMGBD228NLBM[i-1]}
# Differenced MA(1) and ARCH Model for Gold Prices
t <- length(gold_HF$GOLDPMGBD228NLBM)
gold_daily_FD <- rep(0,t-1)
for(i in 2:t){gold_daily_FD[i-1] <- gold_HF$GOLDPMGBD228NLBM[i]-gold_HF$GOLDPMGBD228NLBM[i-1]}
# clear workspace
rm(list=ls())
# load needed libraries
library(readr)
library(vars)
library(tseries)
# import search trends
data <-  read_csv("btc-vs-gold-2004.csv", col_types = cols(Month = col_date(format = "%Y-%m")))
# import prices data:
gold_pr <- read_csv("gold-2004.csv", col_types = cols(DATE = col_date(format = "%Y-%m-%d")))
# import high-frequency prices for gold:
gold_HF <- read_csv('gold-2001-HF.csv', col_types = cols(DATE = col_date(format = '%Y-%m-%d')))
# Differenced MA(1) and ARCH Model for Gold Prices
t <- length(gold_HF$GOLDPMGBD228NLBM)
gold_daily_FD <- rep(0,t-1)
for(i in 2:t){gold_daily_FD[i-1] <- gold_HF$GOLDPMGBD228NLBM[i]-gold_HF$GOLDPMGBD228NLBM[i-1]}
# clear workspace
rm(list=ls())
# load needed libraries
library(readr)
library(vars)
library(tseries)
# set working directory
#setwd("/Users/samue/Downloads/Studium/Economics (Master - Vienna)/2. Semester/Macroeconometrics/Project/macroeconometrics_prices")
# import search trends
data <-  read_csv("btc-vs-gold-2004.csv", col_types = cols(Month = col_date(format = "%Y-%m")))
# import prices data:
gold_pr <- read_csv("gold-2004.csv", col_types = cols(DATE = col_date(format = "%Y-%m-%d")))
# import high-frequency prices for gold:
gold_HF <- read_csv('gold-2001-HF.csv', col_types = cols(DATE = col_date(format = '%Y-%m-%d')))
# create first differenced prices and search interest
t <- length(gold_pr$DATE)
gold_price_FD <- rep(0,t-1)
for(i in 2:209){gold_price_FD[i-1] <- gold_pr$GOLDPMGBD228NLBM[i]-gold_pr$GOLDPMGBD228NLBM[i-1]}
gold_search_FD <- rep(0,t-1)
for(i in 2:209){gold_search_FD[i-1] <- data$GOLD[i]-data$GOLD[i-1]}
t_1 <- length(gold_HF$DATE)
gold_daily_FD <- rep(0,t_1-1)
for(i in 2:t_1){gold_daily_FD[i-1] <- gold_HF$GOLDPMGBD228NLBM[i]-gold_HF$GOLDPMGBD228NLBM[i-1]}
for(i in 2:5332){gold_daily_FD[i-1] <- gold_HF$GOLDPMGBD228NLBM[i]-gold_HF$GOLDPMGBD228NLBM[i-1]}
View(gold_HF)
View(gold_HF)
typeof(gold_HF$GOLDPMGBD228NLBM)
typeof(gold_pr$GOLDPMGBD228NLBM)
# clear workspace
rm(list=ls())
# load needed libraries
library(readr)
library(vars)
library(tseries)
# set working directory
#setwd("/Users/samue/Downloads/Studium/Economics (Master - Vienna)/2. Semester/Macroeconometrics/Project/macroeconometrics_prices")
# import search trends
data <-  read_csv("btc-vs-gold-2004.csv", col_types = cols(Month = col_date(format = "%Y-%m")))
# import prices data:
gold_pr <- read_csv("gold-2004.csv", col_types = cols(DATE = col_date(format = "%Y-%m-%d")))
# import high-frequency prices for gold:
gold_HF <- read_csv('gold-2001-HF.csv', col_types = cols(DATE = col_date(format = '%Y-%m-%d'),GOLDPMGBD228NLBM = col_double()))
t_1 <- length(gold_HF$DATE)
gold_daily_FD <- rep(0,t_1-1)
for(i in 2:5332){gold_daily_FD[i-1] <- gold_HF$GOLDPMGBD228NLBM[i]-gold_HF$GOLDPMGBD228NLBM[i-1]}
# Differenced MA(1) and ARCH Model for Gold Prices
gold_price_FD <- ts(gold_daily_FD, frequency = 365,
start = c(2001, 1, 1), end = c(2021, 6, 10))
plot(gold_price_FD, ylab = 'FD Gold Prices', col = 'red', lwd = 1.5)
ma1mod_FD <- arima(gold_price_FD, order = c(0,0,1))
ma1mod_FD
plot(forecast::arima.errors(ma1mod_FD),type = 'l', lwd = 1.5, col = 'blue',
ylab = 'ARIMA residuals')
mean(forecast::arima.errors(ma1mod_FD))
# LM test on the squared residuals
aTSA::arch.test(ma1mod_FD)
resi_ma1_FD_2 <- (forecast::arima.errors(ma1mod_FD))^2
resi_arch1_FD_2_model <- arima(resi_ma1_FD_2, order = c(3,0,0))
resi_arch1_FD_2_model
# plot the squared residuals:
plot(resi_ma1_FD_2, ylab = 'Squared MA(1) Residuals of FD Gold Price',
xlab = 'Time from 02.2004', col = 'red', lwd = 1.5)
